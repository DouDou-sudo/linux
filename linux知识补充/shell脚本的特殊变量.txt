1 $0 当前脚本的名称
2 $# 传递给脚本或函数的参数个数
3 $* 传递给脚本或函数的所有参数
4 $@ 传递给脚本或函数的所有参数。被双引号""包含时，与 $* 稍有不同
5 $? 上个命令的退出状态，或函数的返回值。
6 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。
7 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数，第一个参数是$1，第二个参数是$2。 

-e 文件（包括目录）是否存在 [ -e / ] 返回 true
-d 文件存在且是目录 [ -d / ] 返回 true
-f 文件存在且是普通文件（既不是目录，也不是设备文件） [ -f /etc/passwd] 返回 true
-L 文件存在且是软链接。同 -h [ -L /etc/passwd ] 返回 false
-r 文件存在且可读 [ -r /etc/passwd ] 返回 true
-w 文件存在且可写 [ -w /etc/shadow ] 返回 false
-x 文件存在且可执行 [ -x /usr/bin/passwd ] 返回 true
-b 文件存在且是块设备文件 [ -b /dev/vda1 ] 返回 true

-------------------$*和$@的区别-------------
当 $* 和 $@ 不被双引号" "包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。
但是当它们被双引号" "包含时，就会有区别了：
    "$*"会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。
    "$@"仍然将每个参数都看作一份数据，彼此之间是独立的。
比如传递了 5 个参数，那么对于"$*"来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于"$@"来说，这 5 个参数是相互独立的，它们是 5 份数据。
如果使用 echo 直接输出"$*"和"$@"做对比，是看不出区别的；但如果使用 for 循环来逐个输出数据，立即就能看出区别来。
编写下面的代码，并保存为 test.sh：

    #!/bin/bash
    echo "print each param from \"\$*\""
    for var in "$*"
    do
        echo "$var"
    done
    echo "print each param from \"\$@\""
    for var in "$@"
    do
        echo "$var"
    done

运行 test.sh，并附带参数：

[mozhiyan@localhost demo]$ . ./test.sh a b c d
print each param from "$*"
a b c d
print each param from "$@"
a
b
c
d