输出不匹配  #开头或者#前面有多个空格开头或者空行的   行
grep -Ev "^[[:space:]]*#|^$" /etc/lvm/lvm.conf
--------------------通配符--------------------ls,find,cp,mv
*		匹配任意0或者多个字符，find . -name ".*"匹配以 . 开头的文件或目录
？		匹配任意一个字符
[abc]或[a,b,c]	匹配[]中的任意一个字符
[^list][!list]	匹配除list中的任意一个字符
[a-z]		匹配a-z中任意一个字符
{string1,string2...}	匹配任一字符串


--------------------正则表达式--------------------
--------字符匹配--------
.		匹配除换行符外的任意单个字符
[]    　　　	匹配指定范围内的任意字符,如：[a-z]、[A-Z]、[0-9]
[^]    　　　　　　	匹配指定范围外的任意单个字符,取反
[[:alnum:]]    　　　	字母和数字,与[A-Za-z0-9]等价
[[:alpa:]]    　　　　	字母,与[A-Za-z]等价
[[:digit:]]    　　　　	数字,与[0-9]等价
[[:xdigit:]]    　　　	十六进制字符,与[0-9A-Fa-f]等价
[[:blank:]]    　　　　空格和制表符
[[:lower:]]    　　　　小写字母
[[:upper:]]    　　　	大写字母
[[:space:]]   　　　	空白字符,等价于[\t\r\n\v\f]
[[:punct:]]    　　	标点符号
\		转义字符
|		或者，匹配两者中的一个即可
--------次数匹配--------
* 	匹配前面的一个字符0次或多次,不能独立使用，和通配符的不一样
\? 	匹配前面的一个字符0次或1次
\+	匹配前面的一个字符1次或多次
\{m,n\}	匹配前面的一个字符至少m次，最多n次
\{m\}    	匹配前面的一个字符m次
\{m,\}   	匹配前面的一个字符至少m次
--------边界匹配--------
^	匹配开头
$	匹配结尾

grep用法
-i  	忽略大小写
-o 	只显示匹配的内容
-l	输出匹配到的文件
-w	严格匹配
-v	输出不匹配的行
-n	在每个匹配行前加上行号

uniq 	去重，只会对连续行进行去重
uniq -c	对重复项计数
abc
123
abc
类似于这种2行abc不会进行去重，一般使用时先进行排序再去重，command | sort -rn | uniq 

sort用法
-n 	根据字符串数值比较排序
-r 	逆序输出排序结果
-b	使用域进行分类，忽略前面的空白区域
-t	域分隔符；用非空格或tab键分割域

sort –t:   /etc/passwd  以:为分隔符，基于第一个域的排序
sort –t: -r  /etc/passwd  逆向排序
sort –t: -k4 /etc/passwd   以:为分隔符的第四个域为基准进行排序